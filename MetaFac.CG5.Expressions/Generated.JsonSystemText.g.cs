#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: JsonSystemText.2.9
// Metadata : MetaFac.CG5.Expressions.Schema
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Mutability;
using MetaFac.CG4.Runtime;
using MetaFac.CG4.Runtime.JsonSystemText;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Numerics;
using System.Text.Json.Serialization;
using MetaFac.Memory;

namespace MetaFac.CG5.Expressions.JsonSystemText
{


    public abstract class EntityBase : IFreezable, IEntityBase
    {
        public static EntityBase Empty => throw new NotSupportedException();
        public const int EntityTag = 0;
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        public void CopyFrom(IEntityBase? source) { }
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public bool Equals(EntityBase? other) => true;
        public override int GetHashCode() => 0;

        public bool IsFreezable() => false;
        public bool IsFrozen() => false;
        public void Freeze() { }
        public bool TryFreeze() => true;
    }


    [JsonDerivedType(typeof(ErrorNode), ErrorNode.EntityTag)]
    [JsonDerivedType(typeof(ConstantNode), ConstantNode.EntityTag)]
    [JsonDerivedType(typeof(NullConstantNode), NullConstantNode.EntityTag)]
    [JsonDerivedType(typeof(BooleanConstantNode), BooleanConstantNode.EntityTag)]
    [JsonDerivedType(typeof(StringConstantNode), StringConstantNode.EntityTag)]
    [JsonDerivedType(typeof(NumericConstantNode), NumericConstantNode.EntityTag)]
    [JsonDerivedType(typeof(IntegerConstantNode), IntegerConstantNode.EntityTag)]
    [JsonDerivedType(typeof(DoubleConstantNode), DoubleConstantNode.EntityTag)]
    [JsonDerivedType(typeof(OperatorNode), OperatorNode.EntityTag)]
    [JsonDerivedType(typeof(BinaryOperatorNode), BinaryOperatorNode.EntityTag)]
    [JsonDerivedType(typeof(VariableNode), VariableNode.EntityTag)]
    [JsonDerivedType(typeof(UnaryExpressionNode), UnaryExpressionNode.EntityTag)]
    [JsonDerivedType(typeof(BinaryExpressionNode), BinaryExpressionNode.EntityTag)]
    [JsonDerivedType(typeof(TertiaryExpressionNode), TertiaryExpressionNode.EntityTag)]
    public partial class Node
    {
    }
    public sealed class Node_Factory : IEntityFactory<INode, Node>
    {
        private static readonly Node_Factory _instance = new Node_Factory();
        public static Node_Factory Instance => _instance;

        public Node? CreateFrom(INode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case ErrorNode.EntityTag: return ErrorNode_Factory.Instance.CreateFrom((IErrorNode)source);
                case ConstantNode.EntityTag: return ConstantNode_Factory.Instance.CreateFrom((IConstantNode)source);
                case NullConstantNode.EntityTag: return NullConstantNode_Factory.Instance.CreateFrom((INullConstantNode)source);
                case BooleanConstantNode.EntityTag: return BooleanConstantNode_Factory.Instance.CreateFrom((IBooleanConstantNode)source);
                case StringConstantNode.EntityTag: return StringConstantNode_Factory.Instance.CreateFrom((IStringConstantNode)source);
                case NumericConstantNode.EntityTag: return NumericConstantNode_Factory.Instance.CreateFrom((INumericConstantNode)source);
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                case OperatorNode.EntityTag: return OperatorNode_Factory.Instance.CreateFrom((IOperatorNode)source);
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                case VariableNode.EntityTag: return VariableNode_Factory.Instance.CreateFrom((IVariableNode)source);
                case UnaryExpressionNode.EntityTag: return UnaryExpressionNode_Factory.Instance.CreateFrom((IUnaryExpressionNode)source);
                case BinaryExpressionNode.EntityTag: return BinaryExpressionNode_Factory.Instance.CreateFrom((IBinaryExpressionNode)source);
                case TertiaryExpressionNode.EntityTag: return TertiaryExpressionNode_Factory.Instance.CreateFrom((ITertiaryExpressionNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(Node)} from {source.GetType().Name}");
            }
        }

        public Node Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(Node)}");
    }
    public partial class Node : EntityBase, INode, IEquatable<Node>
    {
        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;


        public Node() : base()
        {
        }

        public Node(Node? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public Node(INode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public void CopyFrom(INode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
        }

        public bool Equals(Node? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Node other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }
    }

    public sealed class ErrorNode_Factory : IEntityFactory<IErrorNode, ErrorNode>
    {
        private static readonly ErrorNode_Factory _instance = new ErrorNode_Factory();
        public static ErrorNode_Factory Instance => _instance;
        public ErrorNode? CreateFrom(IErrorNode? source) => (source is null) ? null : new ErrorNode(source);
        public ErrorNode Empty => new ErrorNode();
    }
    public partial class ErrorNode : Node, IErrorNode, IEquatable<ErrorNode>
    {
        public new const int EntityTag = 2;
        protected override int OnGetEntityTag() => EntityTag;

        private String? field_Message;
        String? IErrorNode.Message => field_Message;
        public String? Message
        {
            get => field_Message;
            set => field_Message = value;
        }

        public ErrorNode() : base()
        {
        }

        public ErrorNode(ErrorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Message = source.Message;
        }

        public ErrorNode(IErrorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Message = source.Message;
        }

        public void CopyFrom(IErrorNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Message = source.Message;
        }

        public bool Equals(ErrorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Message.ValueEquals(other.Message)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is ErrorNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Message.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    [JsonDerivedType(typeof(NullConstantNode), NullConstantNode.EntityTag)]
    [JsonDerivedType(typeof(BooleanConstantNode), BooleanConstantNode.EntityTag)]
    [JsonDerivedType(typeof(StringConstantNode), StringConstantNode.EntityTag)]
    [JsonDerivedType(typeof(NumericConstantNode), NumericConstantNode.EntityTag)]
    [JsonDerivedType(typeof(IntegerConstantNode), IntegerConstantNode.EntityTag)]
    [JsonDerivedType(typeof(DoubleConstantNode), DoubleConstantNode.EntityTag)]
    [JsonDerivedType(typeof(OperatorNode), OperatorNode.EntityTag)]
    [JsonDerivedType(typeof(BinaryOperatorNode), BinaryOperatorNode.EntityTag)]
    public partial class ConstantNode
    {
    }
    public sealed class ConstantNode_Factory : IEntityFactory<IConstantNode, ConstantNode>
    {
        private static readonly ConstantNode_Factory _instance = new ConstantNode_Factory();
        public static ConstantNode_Factory Instance => _instance;

        public ConstantNode? CreateFrom(IConstantNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case NullConstantNode.EntityTag: return NullConstantNode_Factory.Instance.CreateFrom((INullConstantNode)source);
                case BooleanConstantNode.EntityTag: return BooleanConstantNode_Factory.Instance.CreateFrom((IBooleanConstantNode)source);
                case StringConstantNode.EntityTag: return StringConstantNode_Factory.Instance.CreateFrom((IStringConstantNode)source);
                case NumericConstantNode.EntityTag: return NumericConstantNode_Factory.Instance.CreateFrom((INumericConstantNode)source);
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                case OperatorNode.EntityTag: return OperatorNode_Factory.Instance.CreateFrom((IOperatorNode)source);
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(ConstantNode)} from {source.GetType().Name}");
            }
        }

        public ConstantNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(ConstantNode)}");
    }
    public partial class ConstantNode : Node, IConstantNode, IEquatable<ConstantNode>
    {
        public new const int EntityTag = 3;
        protected override int OnGetEntityTag() => EntityTag;


        public ConstantNode() : base()
        {
        }

        public ConstantNode(ConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public ConstantNode(IConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public void CopyFrom(IConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
        }

        public bool Equals(ConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is ConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }
    }

    public sealed class NullConstantNode_Factory : IEntityFactory<INullConstantNode, NullConstantNode>
    {
        private static readonly NullConstantNode_Factory _instance = new NullConstantNode_Factory();
        public static NullConstantNode_Factory Instance => _instance;
        public NullConstantNode? CreateFrom(INullConstantNode? source) => (source is null) ? null : new NullConstantNode(source);
        public NullConstantNode Empty => new NullConstantNode();
    }
    public partial class NullConstantNode : ConstantNode, INullConstantNode, IEquatable<NullConstantNode>
    {
        public new const int EntityTag = 4;
        protected override int OnGetEntityTag() => EntityTag;


        public NullConstantNode() : base()
        {
        }

        public NullConstantNode(NullConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public NullConstantNode(INullConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public void CopyFrom(INullConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
        }

        public bool Equals(NullConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is NullConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }
    }

    public sealed class BooleanConstantNode_Factory : IEntityFactory<IBooleanConstantNode, BooleanConstantNode>
    {
        private static readonly BooleanConstantNode_Factory _instance = new BooleanConstantNode_Factory();
        public static BooleanConstantNode_Factory Instance => _instance;
        public BooleanConstantNode? CreateFrom(IBooleanConstantNode? source) => (source is null) ? null : new BooleanConstantNode(source);
        public BooleanConstantNode Empty => new BooleanConstantNode();
    }
    public partial class BooleanConstantNode : ConstantNode, IBooleanConstantNode, IEquatable<BooleanConstantNode>
    {
        public new const int EntityTag = 5;
        protected override int OnGetEntityTag() => EntityTag;

        private Boolean field_Value;
        Boolean IBooleanConstantNode.Value { get => field_Value; }
        public Boolean Value
        {
            get => field_Value;
            set => field_Value = value;
        }

        public BooleanConstantNode() : base()
        {
        }

        public BooleanConstantNode(BooleanConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public BooleanConstantNode(IBooleanConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public void CopyFrom(IBooleanConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Value = source.Value;
        }

        public bool Equals(BooleanConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Value.ValueEquals(other.Value)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is BooleanConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Value.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    public sealed class StringConstantNode_Factory : IEntityFactory<IStringConstantNode, StringConstantNode>
    {
        private static readonly StringConstantNode_Factory _instance = new StringConstantNode_Factory();
        public static StringConstantNode_Factory Instance => _instance;
        public StringConstantNode? CreateFrom(IStringConstantNode? source) => (source is null) ? null : new StringConstantNode(source);
        public StringConstantNode Empty => new StringConstantNode();
    }
    public partial class StringConstantNode : ConstantNode, IStringConstantNode, IEquatable<StringConstantNode>
    {
        public new const int EntityTag = 6;
        protected override int OnGetEntityTag() => EntityTag;

        private String? field_Value;
        String? IStringConstantNode.Value => field_Value;
        public String? Value
        {
            get => field_Value;
            set => field_Value = value;
        }

        public StringConstantNode() : base()
        {
        }

        public StringConstantNode(StringConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public StringConstantNode(IStringConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public void CopyFrom(IStringConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Value = source.Value;
        }

        public bool Equals(StringConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Value.ValueEquals(other.Value)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is StringConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Value.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    [JsonDerivedType(typeof(IntegerConstantNode), IntegerConstantNode.EntityTag)]
    [JsonDerivedType(typeof(DoubleConstantNode), DoubleConstantNode.EntityTag)]
    public partial class NumericConstantNode
    {
    }
    public sealed class NumericConstantNode_Factory : IEntityFactory<INumericConstantNode, NumericConstantNode>
    {
        private static readonly NumericConstantNode_Factory _instance = new NumericConstantNode_Factory();
        public static NumericConstantNode_Factory Instance => _instance;

        public NumericConstantNode? CreateFrom(INumericConstantNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case IntegerConstantNode.EntityTag: return IntegerConstantNode_Factory.Instance.CreateFrom((IIntegerConstantNode)source);
                case DoubleConstantNode.EntityTag: return DoubleConstantNode_Factory.Instance.CreateFrom((IDoubleConstantNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(NumericConstantNode)} from {source.GetType().Name}");
            }
        }

        public NumericConstantNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(NumericConstantNode)}");
    }
    public partial class NumericConstantNode : ConstantNode, INumericConstantNode, IEquatable<NumericConstantNode>
    {
        public new const int EntityTag = 7;
        protected override int OnGetEntityTag() => EntityTag;


        public NumericConstantNode() : base()
        {
        }

        public NumericConstantNode(NumericConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public NumericConstantNode(INumericConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public void CopyFrom(INumericConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
        }

        public bool Equals(NumericConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is NumericConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }
    }

    public sealed class IntegerConstantNode_Factory : IEntityFactory<IIntegerConstantNode, IntegerConstantNode>
    {
        private static readonly IntegerConstantNode_Factory _instance = new IntegerConstantNode_Factory();
        public static IntegerConstantNode_Factory Instance => _instance;
        public IntegerConstantNode? CreateFrom(IIntegerConstantNode? source) => (source is null) ? null : new IntegerConstantNode(source);
        public IntegerConstantNode Empty => new IntegerConstantNode();
    }
    public partial class IntegerConstantNode : NumericConstantNode, IIntegerConstantNode, IEquatable<IntegerConstantNode>
    {
        public new const int EntityTag = 8;
        protected override int OnGetEntityTag() => EntityTag;

        private Int64 field_Value;
        Int64 IIntegerConstantNode.Value { get => field_Value; }
        public Int64 Value
        {
            get => field_Value;
            set => field_Value = value;
        }

        public IntegerConstantNode() : base()
        {
        }

        public IntegerConstantNode(IntegerConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public IntegerConstantNode(IIntegerConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public void CopyFrom(IIntegerConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Value = source.Value;
        }

        public bool Equals(IntegerConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Value.ValueEquals(other.Value)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is IntegerConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Value.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    public sealed class DoubleConstantNode_Factory : IEntityFactory<IDoubleConstantNode, DoubleConstantNode>
    {
        private static readonly DoubleConstantNode_Factory _instance = new DoubleConstantNode_Factory();
        public static DoubleConstantNode_Factory Instance => _instance;
        public DoubleConstantNode? CreateFrom(IDoubleConstantNode? source) => (source is null) ? null : new DoubleConstantNode(source);
        public DoubleConstantNode Empty => new DoubleConstantNode();
    }
    public partial class DoubleConstantNode : NumericConstantNode, IDoubleConstantNode, IEquatable<DoubleConstantNode>
    {
        public new const int EntityTag = 9;
        protected override int OnGetEntityTag() => EntityTag;

        private Double field_Value;
        Double IDoubleConstantNode.Value { get => field_Value; }
        public Double Value
        {
            get => field_Value;
            set => field_Value = value;
        }

        public DoubleConstantNode() : base()
        {
        }

        public DoubleConstantNode(DoubleConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public DoubleConstantNode(IDoubleConstantNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public void CopyFrom(IDoubleConstantNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Value = source.Value;
        }

        public bool Equals(DoubleConstantNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Value.ValueEquals(other.Value)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is DoubleConstantNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Value.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    public sealed class VariableNode_Factory : IEntityFactory<IVariableNode, VariableNode>
    {
        private static readonly VariableNode_Factory _instance = new VariableNode_Factory();
        public static VariableNode_Factory Instance => _instance;
        public VariableNode? CreateFrom(IVariableNode? source) => (source is null) ? null : new VariableNode(source);
        public VariableNode Empty => new VariableNode();
    }
    public partial class VariableNode : Node, IVariableNode, IEquatable<VariableNode>
    {
        public new const int EntityTag = 10;
        protected override int OnGetEntityTag() => EntityTag;

        private String? field_Name;
        String? IVariableNode.Name => field_Name;
        public String? Name
        {
            get => field_Name;
            set => field_Name = value;
        }

        public VariableNode() : base()
        {
        }

        public VariableNode(VariableNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Name = source.Name;
        }

        public VariableNode(IVariableNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Name = source.Name;
        }

        public void CopyFrom(IVariableNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Name = source.Name;
        }

        public bool Equals(VariableNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Name.ValueEquals(other.Name)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is VariableNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Name.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    [JsonDerivedType(typeof(BinaryOperatorNode), BinaryOperatorNode.EntityTag)]
    public partial class OperatorNode
    {
    }
    public sealed class OperatorNode_Factory : IEntityFactory<IOperatorNode, OperatorNode>
    {
        private static readonly OperatorNode_Factory _instance = new OperatorNode_Factory();
        public static OperatorNode_Factory Instance => _instance;

        public OperatorNode? CreateFrom(IOperatorNode? source)
        {
            if (source is null) return null;
            int entityTag = source.GetEntityTag();
            switch (entityTag)
            {
                case BinaryOperatorNode.EntityTag: return BinaryOperatorNode_Factory.Instance.CreateFrom((IBinaryOperatorNode)source);
                default:
                    throw new InvalidOperationException($"Unable to create {typeof(OperatorNode)} from {source.GetType().Name}");
            }
        }

        public OperatorNode Empty => throw new NotSupportedException($"Cannot create abstract entity: {typeof(OperatorNode)}");
    }
    public partial class OperatorNode : ConstantNode, IOperatorNode, IEquatable<OperatorNode>
    {
        public new const int EntityTag = 11;
        protected override int OnGetEntityTag() => EntityTag;


        public OperatorNode() : base()
        {
        }

        public OperatorNode(OperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public OperatorNode(IOperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
        }

        public void CopyFrom(IOperatorNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
        }

        public bool Equals(OperatorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is OperatorNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }
    }

    public sealed class BinaryOperatorNode_Factory : IEntityFactory<IBinaryOperatorNode, BinaryOperatorNode>
    {
        private static readonly BinaryOperatorNode_Factory _instance = new BinaryOperatorNode_Factory();
        public static BinaryOperatorNode_Factory Instance => _instance;
        public BinaryOperatorNode? CreateFrom(IBinaryOperatorNode? source) => (source is null) ? null : new BinaryOperatorNode(source);
        public BinaryOperatorNode Empty => new BinaryOperatorNode();
    }
    public partial class BinaryOperatorNode : OperatorNode, IBinaryOperatorNode, IEquatable<BinaryOperatorNode>
    {
        public new const int EntityTag = 12;
        protected override int OnGetEntityTag() => EntityTag;

        private BinaryOperator field_Value;
        BinaryOperator IBinaryOperatorNode.Value { get => field_Value; }
        public BinaryOperator Value
        {
            get => field_Value;
            set => field_Value = value;
        }

        public BinaryOperatorNode() : base()
        {
        }

        public BinaryOperatorNode(BinaryOperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public BinaryOperatorNode(IBinaryOperatorNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Value = source.Value;
        }

        public void CopyFrom(IBinaryOperatorNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Value = source.Value;
        }

        public bool Equals(BinaryOperatorNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Value.ValueEquals(other.Value)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is BinaryOperatorNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Value.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    public sealed class UnaryExpressionNode_Factory : IEntityFactory<IUnaryExpressionNode, UnaryExpressionNode>
    {
        private static readonly UnaryExpressionNode_Factory _instance = new UnaryExpressionNode_Factory();
        public static UnaryExpressionNode_Factory Instance => _instance;
        public UnaryExpressionNode? CreateFrom(IUnaryExpressionNode? source) => (source is null) ? null : new UnaryExpressionNode(source);
        public UnaryExpressionNode Empty => new UnaryExpressionNode();
    }
    public partial class UnaryExpressionNode : Node, IUnaryExpressionNode, IEquatable<UnaryExpressionNode>
    {
        public new const int EntityTag = 13;
        protected override int OnGetEntityTag() => EntityTag;

        private UnaryOperator field_Op;
        UnaryOperator IUnaryExpressionNode.Op { get => field_Op; }
        public UnaryOperator Op
        {
            get => field_Op;
            set => field_Op = value;
        }
        private Node? field_Operand;
        INode? IUnaryExpressionNode.Operand => field_Operand;
        public Node? Operand
        {
            get => field_Operand;
            set => field_Operand = value;
        }

        public UnaryExpressionNode() : base()
        {
        }

        public UnaryExpressionNode(UnaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Op = source.Op;
            field_Operand = source.Operand;
        }

        public UnaryExpressionNode(IUnaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Op = source.Op;
            field_Operand = Node_Factory.Instance.CreateFrom(source.Operand);
        }

        public void CopyFrom(IUnaryExpressionNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Op = source.Op;
            field_Operand = Node_Factory.Instance.CreateFrom(source.Operand);
        }

        public bool Equals(UnaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Op.ValueEquals(other.Op)) return false;
            if (!Operand.ValueEquals(other.Operand)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is UnaryExpressionNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Op.CalcHashUnary());
            hc.Add(Operand.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    public sealed class BinaryExpressionNode_Factory : IEntityFactory<IBinaryExpressionNode, BinaryExpressionNode>
    {
        private static readonly BinaryExpressionNode_Factory _instance = new BinaryExpressionNode_Factory();
        public static BinaryExpressionNode_Factory Instance => _instance;
        public BinaryExpressionNode? CreateFrom(IBinaryExpressionNode? source) => (source is null) ? null : new BinaryExpressionNode(source);
        public BinaryExpressionNode Empty => new BinaryExpressionNode();
    }
    public partial class BinaryExpressionNode : Node, IBinaryExpressionNode, IEquatable<BinaryExpressionNode>
    {
        public new const int EntityTag = 14;
        protected override int OnGetEntityTag() => EntityTag;

        private BinaryOperator field_Op;
        BinaryOperator IBinaryExpressionNode.Op { get => field_Op; }
        public BinaryOperator Op
        {
            get => field_Op;
            set => field_Op = value;
        }
        private Node? field_Left;
        INode? IBinaryExpressionNode.Left => field_Left;
        public Node? Left
        {
            get => field_Left;
            set => field_Left = value;
        }
        private Node? field_Right;
        INode? IBinaryExpressionNode.Right => field_Right;
        public Node? Right
        {
            get => field_Right;
            set => field_Right = value;
        }

        public BinaryExpressionNode() : base()
        {
        }

        public BinaryExpressionNode(BinaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Op = source.Op;
            field_Left = source.Left;
            field_Right = source.Right;
        }

        public BinaryExpressionNode(IBinaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Op = source.Op;
            field_Left = Node_Factory.Instance.CreateFrom(source.Left);
            field_Right = Node_Factory.Instance.CreateFrom(source.Right);
        }

        public void CopyFrom(IBinaryExpressionNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Op = source.Op;
            field_Left = Node_Factory.Instance.CreateFrom(source.Left);
            field_Right = Node_Factory.Instance.CreateFrom(source.Right);
        }

        public bool Equals(BinaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Op.ValueEquals(other.Op)) return false;
            if (!Left.ValueEquals(other.Left)) return false;
            if (!Right.ValueEquals(other.Right)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is BinaryExpressionNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Op.CalcHashUnary());
            hc.Add(Left.CalcHashUnary());
            hc.Add(Right.CalcHashUnary());
            return hc.ToHashCode();
        }
    }

    public sealed class TertiaryExpressionNode_Factory : IEntityFactory<ITertiaryExpressionNode, TertiaryExpressionNode>
    {
        private static readonly TertiaryExpressionNode_Factory _instance = new TertiaryExpressionNode_Factory();
        public static TertiaryExpressionNode_Factory Instance => _instance;
        public TertiaryExpressionNode? CreateFrom(ITertiaryExpressionNode? source) => (source is null) ? null : new TertiaryExpressionNode(source);
        public TertiaryExpressionNode Empty => new TertiaryExpressionNode();
    }
    public partial class TertiaryExpressionNode : Node, ITertiaryExpressionNode, IEquatable<TertiaryExpressionNode>
    {
        public new const int EntityTag = 15;
        protected override int OnGetEntityTag() => EntityTag;

        private TertiaryOperator field_Op;
        TertiaryOperator ITertiaryExpressionNode.Op { get => field_Op; }
        public TertiaryOperator Op
        {
            get => field_Op;
            set => field_Op = value;
        }
        private Node? field_Node1;
        INode? ITertiaryExpressionNode.Node1 => field_Node1;
        public Node? Node1
        {
            get => field_Node1;
            set => field_Node1 = value;
        }
        private Node? field_Node2;
        INode? ITertiaryExpressionNode.Node2 => field_Node2;
        public Node? Node2
        {
            get => field_Node2;
            set => field_Node2 = value;
        }
        private Node? field_Node3;
        INode? ITertiaryExpressionNode.Node3 => field_Node3;
        public Node? Node3
        {
            get => field_Node3;
            set => field_Node3 = value;
        }

        public TertiaryExpressionNode() : base()
        {
        }

        public TertiaryExpressionNode(TertiaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Op = source.Op;
            field_Node1 = source.Node1;
            field_Node2 = source.Node2;
            field_Node3 = source.Node3;
        }

        public TertiaryExpressionNode(ITertiaryExpressionNode? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Op = source.Op;
            field_Node1 = Node_Factory.Instance.CreateFrom(source.Node1);
            field_Node2 = Node_Factory.Instance.CreateFrom(source.Node2);
            field_Node3 = Node_Factory.Instance.CreateFrom(source.Node3);
        }

        public void CopyFrom(ITertiaryExpressionNode? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Op = source.Op;
            field_Node1 = Node_Factory.Instance.CreateFrom(source.Node1);
            field_Node2 = Node_Factory.Instance.CreateFrom(source.Node2);
            field_Node3 = Node_Factory.Instance.CreateFrom(source.Node3);
        }

        public bool Equals(TertiaryExpressionNode? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Op.ValueEquals(other.Op)) return false;
            if (!Node1.ValueEquals(other.Node1)) return false;
            if (!Node2.ValueEquals(other.Node2)) return false;
            if (!Node3.ValueEquals(other.Node3)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is TertiaryExpressionNode other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Op.CalcHashUnary());
            hc.Add(Node1.CalcHashUnary());
            hc.Add(Node2.CalcHashUnary());
            hc.Add(Node3.CalcHashUnary());
            return hc.ToHashCode();
        }
    }


}
